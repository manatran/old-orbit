// Code generated by Prisma (prisma@1.27.4). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  challenge: (where?: ChallengeWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  report: (where?: ReportWhereInput) => Promise<boolean>;
  revision: (where?: RevisionWhereInput) => Promise<boolean>;
  submission: (where?: SubmissionWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  category: (where: CategoryWhereUniqueInput) => CategoryPromise;
  categories: (
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Category>;
  categoriesConnection: (
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CategoryConnectionPromise;
  challenge: (where: ChallengeWhereUniqueInput) => ChallengePromise;
  challenges: (
    args?: {
      where?: ChallengeWhereInput;
      orderBy?: ChallengeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Challenge>;
  challengesConnection: (
    args?: {
      where?: ChallengeWhereInput;
      orderBy?: ChallengeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ChallengeConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentPromise;
  comments: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Comment>;
  commentsConnection: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CommentConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostPromise;
  posts: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Post>;
  postsConnection: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostConnectionPromise;
  report: (where: ReportWhereUniqueInput) => ReportPromise;
  reports: (
    args?: {
      where?: ReportWhereInput;
      orderBy?: ReportOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Report>;
  reportsConnection: (
    args?: {
      where?: ReportWhereInput;
      orderBy?: ReportOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ReportConnectionPromise;
  revision: (where: RevisionWhereUniqueInput) => RevisionPromise;
  revisions: (
    args?: {
      where?: RevisionWhereInput;
      orderBy?: RevisionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Revision>;
  revisionsConnection: (
    args?: {
      where?: RevisionWhereInput;
      orderBy?: RevisionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RevisionConnectionPromise;
  submission: (where: SubmissionWhereUniqueInput) => SubmissionPromise;
  submissions: (
    args?: {
      where?: SubmissionWhereInput;
      orderBy?: SubmissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Submission>;
  submissionsConnection: (
    args?: {
      where?: SubmissionWhereInput;
      orderBy?: SubmissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SubmissionConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagPromise;
  tags: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tag>;
  tagsConnection: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TagConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (
    args: { data: CategoryUpdateInput; where: CategoryWhereUniqueInput }
  ) => CategoryPromise;
  updateManyCategories: (
    args: { data: CategoryUpdateManyMutationInput; where?: CategoryWhereInput }
  ) => BatchPayloadPromise;
  upsertCategory: (
    args: {
      where: CategoryWhereUniqueInput;
      create: CategoryCreateInput;
      update: CategoryUpdateInput;
    }
  ) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createChallenge: (data: ChallengeCreateInput) => ChallengePromise;
  updateChallenge: (
    args: { data: ChallengeUpdateInput; where: ChallengeWhereUniqueInput }
  ) => ChallengePromise;
  updateManyChallenges: (
    args: {
      data: ChallengeUpdateManyMutationInput;
      where?: ChallengeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertChallenge: (
    args: {
      where: ChallengeWhereUniqueInput;
      create: ChallengeCreateInput;
      update: ChallengeUpdateInput;
    }
  ) => ChallengePromise;
  deleteChallenge: (where: ChallengeWhereUniqueInput) => ChallengePromise;
  deleteManyChallenges: (where?: ChallengeWhereInput) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (
    args: { data: CommentUpdateInput; where: CommentWhereUniqueInput }
  ) => CommentPromise;
  updateManyComments: (
    args: { data: CommentUpdateManyMutationInput; where?: CommentWhereInput }
  ) => BatchPayloadPromise;
  upsertComment: (
    args: {
      where: CommentWhereUniqueInput;
      create: CommentCreateInput;
      update: CommentUpdateInput;
    }
  ) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (
    args: { data: PostUpdateInput; where: PostWhereUniqueInput }
  ) => PostPromise;
  updateManyPosts: (
    args: { data: PostUpdateManyMutationInput; where?: PostWhereInput }
  ) => BatchPayloadPromise;
  upsertPost: (
    args: {
      where: PostWhereUniqueInput;
      create: PostCreateInput;
      update: PostUpdateInput;
    }
  ) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createReport: (data: ReportCreateInput) => ReportPromise;
  updateReport: (
    args: { data: ReportUpdateInput; where: ReportWhereUniqueInput }
  ) => ReportPromise;
  updateManyReports: (
    args: { data: ReportUpdateManyMutationInput; where?: ReportWhereInput }
  ) => BatchPayloadPromise;
  upsertReport: (
    args: {
      where: ReportWhereUniqueInput;
      create: ReportCreateInput;
      update: ReportUpdateInput;
    }
  ) => ReportPromise;
  deleteReport: (where: ReportWhereUniqueInput) => ReportPromise;
  deleteManyReports: (where?: ReportWhereInput) => BatchPayloadPromise;
  createRevision: (data: RevisionCreateInput) => RevisionPromise;
  updateRevision: (
    args: { data: RevisionUpdateInput; where: RevisionWhereUniqueInput }
  ) => RevisionPromise;
  updateManyRevisions: (
    args: { data: RevisionUpdateManyMutationInput; where?: RevisionWhereInput }
  ) => BatchPayloadPromise;
  upsertRevision: (
    args: {
      where: RevisionWhereUniqueInput;
      create: RevisionCreateInput;
      update: RevisionUpdateInput;
    }
  ) => RevisionPromise;
  deleteRevision: (where: RevisionWhereUniqueInput) => RevisionPromise;
  deleteManyRevisions: (where?: RevisionWhereInput) => BatchPayloadPromise;
  createSubmission: (data: SubmissionCreateInput) => SubmissionPromise;
  updateSubmission: (
    args: { data: SubmissionUpdateInput; where: SubmissionWhereUniqueInput }
  ) => SubmissionPromise;
  updateManySubmissions: (
    args: {
      data: SubmissionUpdateManyMutationInput;
      where?: SubmissionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSubmission: (
    args: {
      where: SubmissionWhereUniqueInput;
      create: SubmissionCreateInput;
      update: SubmissionUpdateInput;
    }
  ) => SubmissionPromise;
  deleteSubmission: (where: SubmissionWhereUniqueInput) => SubmissionPromise;
  deleteManySubmissions: (where?: SubmissionWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (
    args: { data: TagUpdateInput; where: TagWhereUniqueInput }
  ) => TagPromise;
  updateManyTags: (
    args: { data: TagUpdateManyMutationInput; where?: TagWhereInput }
  ) => BatchPayloadPromise;
  upsertTag: (
    args: {
      where: TagWhereUniqueInput;
      create: TagCreateInput;
      update: TagUpdateInput;
    }
  ) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  challenge: (
    where?: ChallengeSubscriptionWhereInput
  ) => ChallengeSubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  report: (
    where?: ReportSubscriptionWhereInput
  ) => ReportSubscriptionPayloadSubscription;
  revision: (
    where?: RevisionSubscriptionWhereInput
  ) => RevisionSubscriptionPayloadSubscription;
  submission: (
    where?: SubmissionSubscriptionWhereInput
  ) => SubmissionSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "thumbnail_ASC"
  | "thumbnail_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "token_ASC"
  | "token_DESC"
  | "isAdmin_ASC"
  | "isAdmin_DESC";

export type ChallengeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "startsAt_ASC"
  | "startsAt_DESC"
  | "expiresAt_ASC"
  | "expiresAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "period_ASC"
  | "period_DESC";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "thumbnail_ASC"
  | "thumbnail_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "content_ASC"
  | "content_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "pinned_ASC"
  | "pinned_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ReportOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "content_ASC"
  | "content_DESC";

export type RevisionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "content_ASC"
  | "content_DESC";

export type SubmissionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "githubUrl_ASC"
  | "githubUrl_DESC"
  | "thumbnail_ASC"
  | "thumbnail_DESC";

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  token?: String;
  token_not?: String;
  token_in?: String[] | String;
  token_not_in?: String[] | String;
  token_lt?: String;
  token_lte?: String;
  token_gt?: String;
  token_gte?: String;
  token_contains?: String;
  token_not_contains?: String;
  token_starts_with?: String;
  token_not_starts_with?: String;
  token_ends_with?: String;
  token_not_ends_with?: String;
  isAdmin?: Boolean;
  isAdmin_not?: Boolean;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CommentUpsertWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateDataInput;
  create: CommentCreateInput;
}

export interface CommentUpdateManyMutationInput {
  deletedAt?: DateTimeInput;
  content?: String;
}

export interface CommentUpdateWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateDataInput;
}

export interface CategoryScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  thumbnail?: String;
  thumbnail_not?: String;
  thumbnail_in?: String[] | String;
  thumbnail_not_in?: String[] | String;
  thumbnail_lt?: String;
  thumbnail_lte?: String;
  thumbnail_gt?: String;
  thumbnail_gte?: String;
  thumbnail_contains?: String;
  thumbnail_not_contains?: String;
  thumbnail_starts_with?: String;
  thumbnail_not_starts_with?: String;
  thumbnail_ends_with?: String;
  thumbnail_not_ends_with?: String;
  AND?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  OR?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  NOT?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
}

export interface CommentUpdateManyInput {
  create?: CommentCreateInput[] | CommentCreateInput;
  update?:
    | CommentUpdateWithWhereUniqueNestedInput[]
    | CommentUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CommentUpsertWithWhereUniqueNestedInput[]
    | CommentUpsertWithWhereUniqueNestedInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  set?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface SubmissionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SubmissionWhereInput;
  AND?: SubmissionSubscriptionWhereInput[] | SubmissionSubscriptionWhereInput;
  OR?: SubmissionSubscriptionWhereInput[] | SubmissionSubscriptionWhereInput;
  NOT?: SubmissionSubscriptionWhereInput[] | SubmissionSubscriptionWhereInput;
}

export interface RevisionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RevisionWhereInput;
  AND?: RevisionSubscriptionWhereInput[] | RevisionSubscriptionWhereInput;
  OR?: RevisionSubscriptionWhereInput[] | RevisionSubscriptionWhereInput;
  NOT?: RevisionSubscriptionWhereInput[] | RevisionSubscriptionWhereInput;
}

export interface CategoryCreateInput {
  deletedAt?: DateTimeInput;
  name: String;
  description: String;
  thumbnail: String;
  parentCategory?: CategoryCreateOneInput;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostWhereInput;
  AND?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  OR?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  NOT?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
}

export interface CategoryCreateOneInput {
  create?: CategoryCreateInput;
  connect?: CategoryWhereUniqueInput;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CategoryUpdateInput {
  deletedAt?: DateTimeInput;
  name?: String;
  description?: String;
  thumbnail?: String;
  parentCategory?: CategoryUpdateOneInput;
}

export interface TagWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  thumbnail?: String;
  thumbnail_not?: String;
  thumbnail_in?: String[] | String;
  thumbnail_not_in?: String[] | String;
  thumbnail_lt?: String;
  thumbnail_lte?: String;
  thumbnail_gt?: String;
  thumbnail_gte?: String;
  thumbnail_contains?: String;
  thumbnail_not_contains?: String;
  thumbnail_starts_with?: String;
  thumbnail_not_starts_with?: String;
  thumbnail_ends_with?: String;
  thumbnail_not_ends_with?: String;
  parentTag?: TagWhereInput;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export interface CategoryUpdateOneInput {
  create?: CategoryCreateInput;
  update?: CategoryUpdateDataInput;
  upsert?: CategoryUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CategoryWhereUniqueInput;
}

export interface UserUpdateManyMutationInput {
  deletedAt?: DateTimeInput;
  token?: String;
  isAdmin?: Boolean;
}

export interface CategoryUpdateDataInput {
  deletedAt?: DateTimeInput;
  name?: String;
  description?: String;
  thumbnail?: String;
  parentCategory?: CategoryUpdateOneInput;
}

export interface UserUpdateInput {
  deletedAt?: DateTimeInput;
  token?: String;
  isAdmin?: Boolean;
  blacklist?: UserUpdateManyInput;
  subscriptions?: CategoryUpdateManyInput;
}

export interface CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput;
  create: CategoryCreateInput;
}

export interface TagUpdateInput {
  deletedAt?: DateTimeInput;
  name?: String;
  description?: String;
  thumbnail?: String;
  parentTag?: TagUpdateOneInput;
}

export interface CategoryUpdateManyMutationInput {
  deletedAt?: DateTimeInput;
  name?: String;
  description?: String;
  thumbnail?: String;
}

export type PostWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PostUpdateInput {
  deletedAt?: DateTimeInput;
  author?: UserUpdateOneRequiredInput;
  title?: String;
  description?: String;
  comments?: CommentUpdateManyInput;
  tags?: TagUpdateManyInput;
  category?: CategoryUpdateOneRequiredInput;
  pinned?: Boolean;
}

export interface PostWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  author?: UserWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  category?: CategoryWhereInput;
  pinned?: Boolean;
  pinned_not?: Boolean;
  AND?: PostWhereInput[] | PostWhereInput;
  OR?: PostWhereInput[] | PostWhereInput;
  NOT?: PostWhereInput[] | PostWhereInput;
}

export interface CommentCreateManyInput {
  create?: CommentCreateInput[] | CommentCreateInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface ChallengeUpdateOneRequiredInput {
  create?: ChallengeCreateInput;
  update?: ChallengeUpdateDataInput;
  upsert?: ChallengeUpsertNestedInput;
  connect?: ChallengeWhereUniqueInput;
}

export interface ChallengeCreateInput {
  deletedAt?: DateTimeInput;
  startsAt: DateTimeInput;
  expiresAt: DateTimeInput;
  author: UserCreateOneInput;
  title: String;
  description: String;
  period: String;
}

export interface ChallengeCreateOneInput {
  create?: ChallengeCreateInput;
  connect?: ChallengeWhereUniqueInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface SubmissionCreateInput {
  deletedAt?: DateTimeInput;
  author: UserCreateOneInput;
  title: String;
  description: String;
  comments?: CommentCreateManyInput;
  challenge: ChallengeCreateOneInput;
  tags?: TagCreateManyInput;
  githubUrl: String;
  thumbnail: String;
}

export interface UserCreateInput {
  deletedAt?: DateTimeInput;
  token: String;
  isAdmin?: Boolean;
  blacklist?: UserCreateManyInput;
  subscriptions?: CategoryCreateManyInput;
}

export interface CategoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  thumbnail?: String;
  thumbnail_not?: String;
  thumbnail_in?: String[] | String;
  thumbnail_not_in?: String[] | String;
  thumbnail_lt?: String;
  thumbnail_lte?: String;
  thumbnail_gt?: String;
  thumbnail_gte?: String;
  thumbnail_contains?: String;
  thumbnail_not_contains?: String;
  thumbnail_starts_with?: String;
  thumbnail_not_starts_with?: String;
  thumbnail_ends_with?: String;
  thumbnail_not_ends_with?: String;
  parentCategory?: CategoryWhereInput;
  AND?: CategoryWhereInput[] | CategoryWhereInput;
  OR?: CategoryWhereInput[] | CategoryWhereInput;
  NOT?: CategoryWhereInput[] | CategoryWhereInput;
}

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface PostUpsertNestedInput {
  update: PostUpdateDataInput;
  create: PostCreateInput;
}

export interface CategoryCreateManyInput {
  create?: CategoryCreateInput[] | CategoryCreateInput;
  connect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
}

export type RevisionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ChallengeUpdateInput {
  deletedAt?: DateTimeInput;
  startsAt?: DateTimeInput;
  expiresAt?: DateTimeInput;
  author?: UserUpdateOneRequiredInput;
  title?: String;
  description?: String;
  period?: String;
}

export interface RevisionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  author?: UserWhereInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  post?: PostWhereInput;
  AND?: RevisionWhereInput[] | RevisionWhereInput;
  OR?: RevisionWhereInput[] | RevisionWhereInput;
  NOT?: RevisionWhereInput[] | RevisionWhereInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface PostCreateOneInput {
  create?: PostCreateInput;
  connect?: PostWhereUniqueInput;
}

export interface UserUpdateDataInput {
  deletedAt?: DateTimeInput;
  token?: String;
  isAdmin?: Boolean;
  blacklist?: UserUpdateManyInput;
  subscriptions?: CategoryUpdateManyInput;
}

export interface ReportUpdateManyMutationInput {
  deletedAt?: DateTimeInput;
  content?: String;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateOneInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface ReportUpdateInput {
  deletedAt?: DateTimeInput;
  author?: UserUpdateOneRequiredInput;
  content?: String;
  tags?: TagUpdateManyInput;
  resolvedBy?: UserUpdateOneInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface PostUpdateManyMutationInput {
  deletedAt?: DateTimeInput;
  title?: String;
  description?: String;
  pinned?: Boolean;
}

export interface PostCreateInput {
  deletedAt?: DateTimeInput;
  author: UserCreateOneInput;
  title: String;
  description: String;
  comments?: CommentCreateManyInput;
  tags?: TagCreateManyInput;
  category: CategoryCreateOneInput;
  pinned?: Boolean;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  deletedAt?: DateTimeInput;
  token?: String;
  isAdmin?: Boolean;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CategoryUpdateManyInput {
  create?: CategoryCreateInput[] | CategoryCreateInput;
  update?:
    | CategoryUpdateWithWhereUniqueNestedInput[]
    | CategoryUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CategoryUpsertWithWhereUniqueNestedInput[]
    | CategoryUpsertWithWhereUniqueNestedInput;
  delete?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  connect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  set?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  disconnect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  deleteMany?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  updateMany?:
    | CategoryUpdateManyWithWhereNestedInput[]
    | CategoryUpdateManyWithWhereNestedInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  token?: String;
  token_not?: String;
  token_in?: String[] | String;
  token_not_in?: String[] | String;
  token_lt?: String;
  token_lte?: String;
  token_gt?: String;
  token_gte?: String;
  token_contains?: String;
  token_not_contains?: String;
  token_starts_with?: String;
  token_not_starts_with?: String;
  token_ends_with?: String;
  token_not_ends_with?: String;
  isAdmin?: Boolean;
  isAdmin_not?: Boolean;
  blacklist_every?: UserWhereInput;
  blacklist_some?: UserWhereInput;
  blacklist_none?: UserWhereInput;
  subscriptions_every?: CategoryWhereInput;
  subscriptions_some?: CategoryWhereInput;
  subscriptions_none?: CategoryWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface CategoryUpdateWithWhereUniqueNestedInput {
  where: CategoryWhereUniqueInput;
  data: CategoryUpdateDataInput;
}

export interface ReportSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ReportWhereInput;
  AND?: ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput;
  OR?: ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput;
  NOT?: ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput;
}

export interface CategoryUpsertWithWhereUniqueNestedInput {
  where: CategoryWhereUniqueInput;
  update: CategoryUpdateDataInput;
  create: CategoryCreateInput;
}

export interface ChallengeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ChallengeWhereInput;
  AND?: ChallengeSubscriptionWhereInput[] | ChallengeSubscriptionWhereInput;
  OR?: ChallengeSubscriptionWhereInput[] | ChallengeSubscriptionWhereInput;
  NOT?: ChallengeSubscriptionWhereInput[] | ChallengeSubscriptionWhereInput;
}

export type ChallengeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CommentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  author?: UserWhereInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  likes_every?: UserWhereInput;
  likes_some?: UserWhereInput;
  likes_none?: UserWhereInput;
  parentComment?: CommentWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  AND?: CommentWhereInput[] | CommentWhereInput;
  OR?: CommentWhereInput[] | CommentWhereInput;
  NOT?: CommentWhereInput[] | CommentWhereInput;
}

export interface CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput;
  data: CategoryUpdateManyDataInput;
}

export interface SubmissionUpdateManyMutationInput {
  deletedAt?: DateTimeInput;
  title?: String;
  description?: String;
  githubUrl?: String;
  thumbnail?: String;
}

export interface CategoryUpdateManyDataInput {
  deletedAt?: DateTimeInput;
  name?: String;
  description?: String;
  thumbnail?: String;
}

export interface ChallengeUpdateDataInput {
  deletedAt?: DateTimeInput;
  startsAt?: DateTimeInput;
  expiresAt?: DateTimeInput;
  author?: UserUpdateOneRequiredInput;
  title?: String;
  description?: String;
  period?: String;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export type ReportWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ChallengeUpdateManyMutationInput {
  deletedAt?: DateTimeInput;
  startsAt?: DateTimeInput;
  expiresAt?: DateTimeInput;
  title?: String;
  description?: String;
  period?: String;
}

export interface RevisionUpdateManyMutationInput {
  deletedAt?: DateTimeInput;
  content?: String;
}

export interface CommentCreateInput {
  deletedAt?: DateTimeInput;
  author: UserCreateOneInput;
  content: String;
  likes?: UserCreateManyInput;
  parentComment: CommentCreateOneInput;
  tags?: TagCreateManyInput;
}

export interface PostUpdateOneRequiredInput {
  create?: PostCreateInput;
  update?: PostUpdateDataInput;
  upsert?: PostUpsertNestedInput;
  connect?: PostWhereUniqueInput;
}

export interface CommentCreateOneInput {
  create?: CommentCreateInput;
  connect?: CommentWhereUniqueInput;
}

export interface RevisionCreateInput {
  deletedAt?: DateTimeInput;
  author: UserCreateOneInput;
  content: String;
  post: PostCreateOneInput;
}

export interface TagCreateManyInput {
  create?: TagCreateInput[] | TagCreateInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface SubmissionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  author?: UserWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  challenge?: ChallengeWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  githubUrl?: String;
  githubUrl_not?: String;
  githubUrl_in?: String[] | String;
  githubUrl_not_in?: String[] | String;
  githubUrl_lt?: String;
  githubUrl_lte?: String;
  githubUrl_gt?: String;
  githubUrl_gte?: String;
  githubUrl_contains?: String;
  githubUrl_not_contains?: String;
  githubUrl_starts_with?: String;
  githubUrl_not_starts_with?: String;
  githubUrl_ends_with?: String;
  githubUrl_not_ends_with?: String;
  thumbnail?: String;
  thumbnail_not?: String;
  thumbnail_in?: String[] | String;
  thumbnail_not_in?: String[] | String;
  thumbnail_lt?: String;
  thumbnail_lte?: String;
  thumbnail_gt?: String;
  thumbnail_gte?: String;
  thumbnail_contains?: String;
  thumbnail_not_contains?: String;
  thumbnail_starts_with?: String;
  thumbnail_not_starts_with?: String;
  thumbnail_ends_with?: String;
  thumbnail_not_ends_with?: String;
  AND?: SubmissionWhereInput[] | SubmissionWhereInput;
  OR?: SubmissionWhereInput[] | SubmissionWhereInput;
  NOT?: SubmissionWhereInput[] | SubmissionWhereInput;
}

export interface TagCreateInput {
  deletedAt?: DateTimeInput;
  name: String;
  description: String;
  thumbnail: String;
  parentTag?: TagCreateOneInput;
}

export interface CategoryUpdateOneRequiredInput {
  create?: CategoryCreateInput;
  update?: CategoryUpdateDataInput;
  upsert?: CategoryUpsertNestedInput;
  connect?: CategoryWhereUniqueInput;
}

export interface TagCreateOneInput {
  create?: TagCreateInput;
  connect?: TagWhereUniqueInput;
}

export interface CommentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  AND?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  OR?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  NOT?: CommentScalarWhereInput[] | CommentScalarWhereInput;
}

export interface CommentUpdateInput {
  deletedAt?: DateTimeInput;
  author?: UserUpdateOneRequiredInput;
  content?: String;
  likes?: UserUpdateManyInput;
  parentComment?: CommentUpdateOneRequiredInput;
  tags?: TagUpdateManyInput;
}

export interface ChallengeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  startsAt?: DateTimeInput;
  startsAt_not?: DateTimeInput;
  startsAt_in?: DateTimeInput[] | DateTimeInput;
  startsAt_not_in?: DateTimeInput[] | DateTimeInput;
  startsAt_lt?: DateTimeInput;
  startsAt_lte?: DateTimeInput;
  startsAt_gt?: DateTimeInput;
  startsAt_gte?: DateTimeInput;
  expiresAt?: DateTimeInput;
  expiresAt_not?: DateTimeInput;
  expiresAt_in?: DateTimeInput[] | DateTimeInput;
  expiresAt_not_in?: DateTimeInput[] | DateTimeInput;
  expiresAt_lt?: DateTimeInput;
  expiresAt_lte?: DateTimeInput;
  expiresAt_gt?: DateTimeInput;
  expiresAt_gte?: DateTimeInput;
  author?: UserWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  period?: String;
  period_not?: String;
  period_in?: String[] | String;
  period_not_in?: String[] | String;
  period_lt?: String;
  period_lte?: String;
  period_gt?: String;
  period_gte?: String;
  period_contains?: String;
  period_not_contains?: String;
  period_starts_with?: String;
  period_not_starts_with?: String;
  period_ends_with?: String;
  period_not_ends_with?: String;
  AND?: ChallengeWhereInput[] | ChallengeWhereInput;
  OR?: ChallengeWhereInput[] | ChallengeWhereInput;
  NOT?: ChallengeWhereInput[] | ChallengeWhereInput;
}

export interface CommentUpdateOneRequiredInput {
  create?: CommentCreateInput;
  update?: CommentUpdateDataInput;
  upsert?: CommentUpsertNestedInput;
  connect?: CommentWhereUniqueInput;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CategoryWhereInput;
  AND?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
  OR?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
  NOT?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
}

export interface CommentUpdateDataInput {
  deletedAt?: DateTimeInput;
  author?: UserUpdateOneRequiredInput;
  content?: String;
  likes?: UserUpdateManyInput;
  parentComment?: CommentUpdateOneRequiredInput;
  tags?: TagUpdateManyInput;
}

export interface ChallengeUpsertNestedInput {
  update: ChallengeUpdateDataInput;
  create: ChallengeCreateInput;
}

export interface TagUpdateManyInput {
  create?: TagCreateInput[] | TagCreateInput;
  update?:
    | TagUpdateWithWhereUniqueNestedInput[]
    | TagUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TagUpsertWithWhereUniqueNestedInput[]
    | TagUpsertWithWhereUniqueNestedInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  set?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  deleteMany?: TagScalarWhereInput[] | TagScalarWhereInput;
  updateMany?:
    | TagUpdateManyWithWhereNestedInput[]
    | TagUpdateManyWithWhereNestedInput;
}

export interface ReportWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  author?: UserWhereInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  resolvedBy?: UserWhereInput;
  AND?: ReportWhereInput[] | ReportWhereInput;
  OR?: ReportWhereInput[] | ReportWhereInput;
  NOT?: ReportWhereInput[] | ReportWhereInput;
}

export interface TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  data: TagUpdateDataInput;
}

export interface RevisionUpdateInput {
  deletedAt?: DateTimeInput;
  author?: UserUpdateOneRequiredInput;
  content?: String;
  post?: PostUpdateOneRequiredInput;
}

export interface TagUpdateDataInput {
  deletedAt?: DateTimeInput;
  name?: String;
  description?: String;
  thumbnail?: String;
  parentTag?: TagUpdateOneInput;
}

export interface ReportCreateInput {
  deletedAt?: DateTimeInput;
  author: UserCreateOneInput;
  content: String;
  tags?: TagCreateManyInput;
  resolvedBy?: UserCreateOneInput;
}

export interface TagUpdateOneInput {
  create?: TagCreateInput;
  update?: TagUpdateDataInput;
  upsert?: TagUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TagWhereUniqueInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface TagUpsertNestedInput {
  update: TagUpdateDataInput;
  create: TagCreateInput;
}

export interface TagUpdateManyMutationInput {
  deletedAt?: DateTimeInput;
  name?: String;
  description?: String;
  thumbnail?: String;
}

export interface TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  update: TagUpdateDataInput;
  create: TagCreateInput;
}

export interface PostUpdateDataInput {
  deletedAt?: DateTimeInput;
  author?: UserUpdateOneRequiredInput;
  title?: String;
  description?: String;
  comments?: CommentUpdateManyInput;
  tags?: TagUpdateManyInput;
  category?: CategoryUpdateOneRequiredInput;
  pinned?: Boolean;
}

export interface CommentUpsertNestedInput {
  update: CommentUpdateDataInput;
  create: CommentCreateInput;
}

export interface TagUpdateManyDataInput {
  deletedAt?: DateTimeInput;
  name?: String;
  description?: String;
  thumbnail?: String;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface TagScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  thumbnail?: String;
  thumbnail_not?: String;
  thumbnail_in?: String[] | String;
  thumbnail_not_in?: String[] | String;
  thumbnail_lt?: String;
  thumbnail_lte?: String;
  thumbnail_gt?: String;
  thumbnail_gte?: String;
  thumbnail_contains?: String;
  thumbnail_not_contains?: String;
  thumbnail_starts_with?: String;
  thumbnail_not_starts_with?: String;
  thumbnail_ends_with?: String;
  thumbnail_not_ends_with?: String;
  AND?: TagScalarWhereInput[] | TagScalarWhereInput;
  OR?: TagScalarWhereInput[] | TagScalarWhereInput;
  NOT?: TagScalarWhereInput[] | TagScalarWhereInput;
}

export type SubmissionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SubmissionUpdateInput {
  deletedAt?: DateTimeInput;
  author?: UserUpdateOneRequiredInput;
  title?: String;
  description?: String;
  comments?: CommentUpdateManyInput;
  challenge?: ChallengeUpdateOneRequiredInput;
  tags?: TagUpdateManyInput;
  githubUrl?: String;
  thumbnail?: String;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommentWhereInput;
  AND?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  OR?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  NOT?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
}

export interface CommentUpdateManyDataInput {
  deletedAt?: DateTimeInput;
  content?: String;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  token: String;
  isAdmin: Boolean;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  token: () => Promise<String>;
  isAdmin: () => Promise<Boolean>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  token: () => Promise<AsyncIterator<String>>;
  isAdmin: () => Promise<AsyncIterator<Boolean>>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Tag {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  name: String;
  description: String;
  thumbnail: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  thumbnail: () => Promise<String>;
  parentTag: <T = TagPromise>() => T;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
  parentTag: <T = TagSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Category {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  name: String;
  description: String;
  thumbnail: String;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  thumbnail: () => Promise<String>;
  parentCategory: <T = CategoryPromise>() => T;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
  parentCategory: <T = CategorySubscription>() => T;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface SubmissionEdge {
  node: Submission;
  cursor: String;
}

export interface SubmissionEdgePromise
  extends Promise<SubmissionEdge>,
    Fragmentable {
  node: <T = SubmissionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubmissionEdgeSubscription
  extends Promise<AsyncIterator<SubmissionEdge>>,
    Fragmentable {
  node: <T = SubmissionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubmission {
  count: Int;
}

export interface AggregateSubmissionPromise
  extends Promise<AggregateSubmission>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubmissionSubscription
  extends Promise<AsyncIterator<AggregateSubmission>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  token: String;
  isAdmin: Boolean;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  token: () => Promise<String>;
  isAdmin: () => Promise<Boolean>;
  blacklist: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  subscriptions: <T = FragmentableArray<Category>>(
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  token: () => Promise<AsyncIterator<String>>;
  isAdmin: () => Promise<AsyncIterator<Boolean>>;
  blacklist: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  subscriptions: <T = Promise<AsyncIterator<CategorySubscription>>>(
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SubmissionConnection {
  pageInfo: PageInfo;
  edges: SubmissionEdge[];
}

export interface SubmissionConnectionPromise
  extends Promise<SubmissionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubmissionEdge>>() => T;
  aggregate: <T = AggregateSubmissionPromise>() => T;
}

export interface SubmissionConnectionSubscription
  extends Promise<AsyncIterator<SubmissionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubmissionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubmissionSubscription>() => T;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  name: String;
  description: String;
  thumbnail: String;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  thumbnail: () => Promise<String>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
}

export interface Submission {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  title: String;
  description: String;
  githubUrl: String;
  thumbnail: String;
}

export interface SubmissionPromise extends Promise<Submission>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  challenge: <T = ChallengePromise>() => T;
  tags: <T = FragmentableArray<Tag>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  githubUrl: () => Promise<String>;
  thumbnail: () => Promise<String>;
}

export interface SubmissionSubscription
  extends Promise<AsyncIterator<Submission>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  challenge: <T = ChallengeSubscription>() => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  githubUrl: () => Promise<AsyncIterator<String>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
}

export interface RevisionEdge {
  node: Revision;
  cursor: String;
}

export interface RevisionEdgePromise
  extends Promise<RevisionEdge>,
    Fragmentable {
  node: <T = RevisionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RevisionEdgeSubscription
  extends Promise<AsyncIterator<RevisionEdge>>,
    Fragmentable {
  node: <T = RevisionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Comment {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  content: String;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  content: () => Promise<String>;
  likes: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  parentComment: <T = CommentPromise>() => T;
  tags: <T = FragmentableArray<Tag>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  likes: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  parentComment: <T = CommentSubscription>() => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ChallengeSubscriptionPayload {
  mutation: MutationType;
  node: Challenge;
  updatedFields: String[];
  previousValues: ChallengePreviousValues;
}

export interface ChallengeSubscriptionPayloadPromise
  extends Promise<ChallengeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChallengePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChallengePreviousValuesPromise>() => T;
}

export interface ChallengeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChallengeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChallengeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChallengePreviousValuesSubscription>() => T;
}

export interface AggregateReport {
  count: Int;
}

export interface AggregateReportPromise
  extends Promise<AggregateReport>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReportSubscription
  extends Promise<AsyncIterator<AggregateReport>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChallengePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  startsAt: DateTimeOutput;
  expiresAt: DateTimeOutput;
  title: String;
  description: String;
  period: String;
}

export interface ChallengePreviousValuesPromise
  extends Promise<ChallengePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  startsAt: () => Promise<DateTimeOutput>;
  expiresAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  period: () => Promise<String>;
}

export interface ChallengePreviousValuesSubscription
  extends Promise<AsyncIterator<ChallengePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  startsAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  expiresAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  period: () => Promise<AsyncIterator<String>>;
}

export interface ReportConnection {
  pageInfo: PageInfo;
  edges: ReportEdge[];
}

export interface ReportConnectionPromise
  extends Promise<ReportConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReportEdge>>() => T;
  aggregate: <T = AggregateReportPromise>() => T;
}

export interface ReportConnectionSubscription
  extends Promise<AsyncIterator<ReportConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReportEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReportSubscription>() => T;
}

export interface AggregateChallenge {
  count: Int;
}

export interface AggregateChallengePromise
  extends Promise<AggregateChallenge>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChallengeSubscription
  extends Promise<AsyncIterator<AggregateChallenge>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  content: String;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface Post {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  title: String;
  description: String;
  pinned: Boolean;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = FragmentableArray<Tag>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  category: <T = CategoryPromise>() => T;
  pinned: () => Promise<Boolean>;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  category: <T = CategorySubscription>() => T;
  pinned: () => Promise<AsyncIterator<Boolean>>;
}

export interface ChallengeEdge {
  node: Challenge;
  cursor: String;
}

export interface ChallengeEdgePromise
  extends Promise<ChallengeEdge>,
    Fragmentable {
  node: <T = ChallengePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChallengeEdgeSubscription
  extends Promise<AsyncIterator<ChallengeEdge>>,
    Fragmentable {
  node: <T = ChallengeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  title: String;
  description: String;
  pinned: Boolean;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  pinned: () => Promise<Boolean>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  pinned: () => Promise<AsyncIterator<Boolean>>;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ChallengeConnection {
  pageInfo: PageInfo;
  edges: ChallengeEdge[];
}

export interface ChallengeConnectionPromise
  extends Promise<ChallengeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChallengeEdge>>() => T;
  aggregate: <T = AggregateChallengePromise>() => T;
}

export interface ChallengeConnectionSubscription
  extends Promise<AsyncIterator<ChallengeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChallengeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChallengeSubscription>() => T;
}

export interface RevisionConnection {
  pageInfo: PageInfo;
  edges: RevisionEdge[];
}

export interface RevisionConnectionPromise
  extends Promise<RevisionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RevisionEdge>>() => T;
  aggregate: <T = AggregateRevisionPromise>() => T;
}

export interface RevisionConnectionSubscription
  extends Promise<AsyncIterator<RevisionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RevisionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRevisionSubscription>() => T;
}

export interface ReportSubscriptionPayload {
  mutation: MutationType;
  node: Report;
  updatedFields: String[];
  previousValues: ReportPreviousValues;
}

export interface ReportSubscriptionPayloadPromise
  extends Promise<ReportSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReportPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReportPreviousValuesPromise>() => T;
}

export interface ReportSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReportSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReportSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReportPreviousValuesSubscription>() => T;
}

export interface ReportEdge {
  node: Report;
  cursor: String;
}

export interface ReportEdgePromise extends Promise<ReportEdge>, Fragmentable {
  node: <T = ReportPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReportEdgeSubscription
  extends Promise<AsyncIterator<ReportEdge>>,
    Fragmentable {
  node: <T = ReportSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ReportPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  content: String;
}

export interface ReportPreviousValuesPromise
  extends Promise<ReportPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
}

export interface ReportPreviousValuesSubscription
  extends Promise<AsyncIterator<ReportPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RevisionSubscriptionPayload {
  mutation: MutationType;
  node: Revision;
  updatedFields: String[];
  previousValues: RevisionPreviousValues;
}

export interface RevisionSubscriptionPayloadPromise
  extends Promise<RevisionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RevisionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RevisionPreviousValuesPromise>() => T;
}

export interface RevisionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RevisionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RevisionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RevisionPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Revision {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  content: String;
}

export interface RevisionPromise extends Promise<Revision>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  content: () => Promise<String>;
  post: <T = PostPromise>() => T;
}

export interface RevisionSubscription
  extends Promise<AsyncIterator<Revision>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  post: <T = PostSubscription>() => T;
}

export interface SubmissionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  title: String;
  description: String;
  githubUrl: String;
  thumbnail: String;
}

export interface SubmissionPreviousValuesPromise
  extends Promise<SubmissionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  githubUrl: () => Promise<String>;
  thumbnail: () => Promise<String>;
}

export interface SubmissionPreviousValuesSubscription
  extends Promise<AsyncIterator<SubmissionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  githubUrl: () => Promise<AsyncIterator<String>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
}

export interface SubmissionSubscriptionPayload {
  mutation: MutationType;
  node: Submission;
  updatedFields: String[];
  previousValues: SubmissionPreviousValues;
}

export interface SubmissionSubscriptionPayloadPromise
  extends Promise<SubmissionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubmissionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubmissionPreviousValuesPromise>() => T;
}

export interface SubmissionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubmissionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubmissionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubmissionPreviousValuesSubscription>() => T;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RevisionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  content: String;
}

export interface RevisionPreviousValuesPromise
  extends Promise<RevisionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
}

export interface RevisionPreviousValuesSubscription
  extends Promise<AsyncIterator<RevisionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface Report {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  content: String;
}

export interface ReportPromise extends Promise<Report>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  content: () => Promise<String>;
  tags: <T = FragmentableArray<Tag>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  resolvedBy: <T = UserPromise>() => T;
}

export interface ReportSubscription
  extends Promise<AsyncIterator<Report>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  resolvedBy: <T = UserSubscription>() => T;
}

export interface AggregateRevision {
  count: Int;
}

export interface AggregateRevisionPromise
  extends Promise<AggregateRevision>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRevisionSubscription
  extends Promise<AsyncIterator<AggregateRevision>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  name: String;
  description: String;
  thumbnail: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  thumbnail: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
}

export interface Challenge {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  startsAt: DateTimeOutput;
  expiresAt: DateTimeOutput;
  title: String;
  description: String;
  period: String;
}

export interface ChallengePromise extends Promise<Challenge>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  startsAt: () => Promise<DateTimeOutput>;
  expiresAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  period: () => Promise<String>;
}

export interface ChallengeSubscription
  extends Promise<AsyncIterator<Challenge>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  startsAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  expiresAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  period: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Submission",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "Challenge",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Revision",
    embedded: false
  },
  {
    name: "Report",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
